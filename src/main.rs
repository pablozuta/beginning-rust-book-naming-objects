fn main() {
  // in source code, you may want to associate names to objects, to reference them later.
  // this statement declares and initializes a variable.
  let numero = 12;
  let otro_numero = 23;
  let numero_azul = 345;
  // The operation of reserving a memory area for an object is named “allocation”.
  // the removal of an object, causing its memory area to become available is named 
  // “deallocation”
  println!("{}", numero + otro_numero + numero_azul); 

  let otro_numero_mas = 463;
  println!("{}   {}", otro_numero_mas, 34);

  // mutable variables
  let mut number = 12;
  println!("{}", number);
  number = 84;
  println!("{}", number);
  let mut cuerda = "This is a String";
  println!("{}", cuerda);
  cuerda = "Ahora es otro string ";
  println!("{}", cuerda);
  // The simple keyword "let" declares an immutable variable
  // whereas the sequence "let mut" is required to be able to declare a mutable variable.

  // the leading underscore , silence the compiler warnings for unused variables
  let _number_two = 200;

  // boolean values
  let verdad = true;
  // boolean value mutable declaration
  let mut mentira = false;
  println!("{} {}", verdad, mentira);
  mentira = true;
  println!("{} {}", verdad, mentira);

  // Boolean values generated by relational expressions.
  let verdad_dos = 483 > 89 ;
  let mentira_dos = 53 > 64;
  println!("483 es mayor a 89?{} 53 es mayor a 64?{}", verdad_dos, mentira_dos);
  // the two values to be compared must be of the same type. 
  // For example, the expression 3.14 > 3 is invalid.

  // “less-than” operator used directly in the expression
  println!("Esto usara directamente la expresion 2 == 3? {}", 2 == 3);

  // != is different from
  println!("Esto usara directamente la expresion 2 != 3? {}", 2 != 3);
  // Rust relational operators are the same ones used in the C language.
  
  // applicable to strings.
  println!("{}", "Deckard" != "Good-by");

  // When comparing strings, the "<" operator, instead 
  // of being thought of as “is less than”, should be thought of as “precedes”, 
  // and the ">" operator should be thought of as “follows”. 
  // The sort criterion is that of language dictionaries, also known as “lexicographical”.
  println!("La letra A viene antes que la B?{}", "A" < "B");


  // Boolean values can be combined with the so-called logical connectives:
  let truth = true;
  let falsity = false;

  // the ! connective give us the opposite of a boolean
  // The operator "!", read “not”, produces a true value for a false argument
  // and a false value for a true argument.
  let contrario_a_verdad = ! truth;
  let contrario_a_mentira = ! falsity;
  println!("lo contrario a true es?{}", contrario_a_verdad);
  println!("lo contrario a false es?{}", contrario_a_mentira);

  // the && connective is like a logical gate AND
  // produces a true value if both its arguments are true
  // and a false value in the other cases.
  println!("resultado de logical gate verdad && verdad nos da: {}", truth && truth);
  println!("resultado de logical gate mentira && verdad nos da: {}", falsity && truth);

  // the || connective is like a logical gate OR
  // produces a false value if both its arguments are false
  // and a true value in the other cases.
  println!("resultado de logical gate mentira || mentira nos da: {}", falsity || falsity);
  println!("resultado de logical gate verdad || verdad nos da: {}", truth || truth);
  println!("resultado de logical gate mentira || verdad nos da: {}", falsity || truth);



  
  
}
